<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Automerge"><meta name="keywords" content="rust, rustlang, rust-lang, automerge"><title>automerge - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https:///raw.githubusercontent.com/automerge/automerge-rs/main/img/favicon.ico"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../automerge/index.html"><div class="logo-container"><img src="https://raw.githubusercontent.com/automerge/automerge-rs/main/img/brandmark.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../automerge/index.html"><div class="logo-container">
                    <img src="https://raw.githubusercontent.com/automerge/automerge-rs/main/img/brandmark.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate automerge</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.3.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">automerge</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/automerge/lib.rs.html#1-304">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="automerge"><a href="#automerge">Automerge</a></h2>
<p>Automerge is a library of data structures for building collaborative,
<a href="https://www.inkandswitch.com/local-first/">local-first</a> applications. The
idea of automerge is to provide a data structure which is quite general,
- consisting of nested key/value maps and/or lists - which can be modified
entirely locally but which can at any time be merged with other instances of
the same data structure.</p>
<p>In addition to the core data structure (which we generally refer to as a
“document”), we also provide an implementation of a sync protocol (in
<a href="sync/index.html" title="crate::sync"><code>crate::sync</code></a>) which can be used over any reliable in-order transport; and
an efficient binary storage format.</p>
<p>This crate is organised around two representations of a document -
<a href="struct.Automerge.html" title="Automerge"><code>Automerge</code></a> and <a href="type.AutoCommit.html" title="AutoCommit"><code>AutoCommit</code></a>. The difference between the two is that
<a href="type.AutoCommit.html" title="AutoCommit"><code>AutoCommit</code></a> manages transactions for you. Both of these representations
implement <a href="trait.ReadDoc.html" title="ReadDoc"><code>ReadDoc</code></a> for reading values from a document and
<a href="sync/trait.SyncDoc.html" title="sync::SyncDoc"><code>sync::SyncDoc</code></a> for taking part in the sync protocol. <a href="type.AutoCommit.html" title="AutoCommit"><code>AutoCommit</code></a>
directly implements <a href="transaction/trait.Transactable.html" title="transaction::Transactable"><code>transaction::Transactable</code></a> for making changes to a
document, whilst <a href="struct.Automerge.html" title="Automerge"><code>Automerge</code></a> requires you to explicitly create a
<a href="transaction/struct.Transaction.html" title="transaction::Transaction"><code>transaction::Transaction</code></a>.</p>
<p>NOTE: The API this library provides for modifying data is quite low level
(somewhat analogous to directly creating JSON values rather than using
<code>serde</code> derive macros or equivalent). If you’re writing a Rust application which uses automerge
you may want to look at <a href="https://github.com/automerge/autosurgeon">autosurgeon</a>.</p>
<h3 id="data-model"><a href="#data-model">Data Model</a></h3>
<p>An automerge document is a map from strings to values
(<a href="enum.Value.html" title="Value"><code>Value</code></a>) where values can be either</p>
<ul>
<li>A nested composite value which is either
<ul>
<li>A map from strings to values (<a href="enum.ObjType.html#variant.Map" title="ObjType::Map"><code>ObjType::Map</code></a>)</li>
<li>A list of values (<a href="enum.ObjType.html#variant.List" title="ObjType::List"><code>ObjType::List</code></a>)</li>
<li>A text object (a sequence of unicode characters) (<a href="enum.ObjType.html#variant.Text" title="ObjType::Text"><code>ObjType::Text</code></a>)</li>
</ul>
</li>
<li>A primitive value (<a href="enum.ScalarValue.html" title="ScalarValue"><code>ScalarValue</code></a>) which is one of
<ul>
<li>A string</li>
<li>A 64 bit floating point number</li>
<li>A signed 64 bit integer</li>
<li>An unsigned 64 bit integer</li>
<li>A boolean</li>
<li>A counter object (a 64 bit integer which merges by addition)
(<a href="enum.ScalarValue.html#variant.Counter" title="ScalarValue::Counter"><code>ScalarValue::Counter</code></a>)</li>
<li>A timestamp (a 64 bit integer which is milliseconds since the unix epoch)</li>
</ul>
</li>
</ul>
<p>All composite values have an ID (<a href="enum.ObjId.html" title="ObjId"><code>ObjId</code></a>) which is created when the value
is inserted into the document or is the root object ID <a href="constant.ROOT.html" title="ROOT"><code>ROOT</code></a>. Values in
the document are then referred to by the pair (<code>object ID</code>, <code>key</code>). The
<code>key</code> is represented by the <a href="enum.Prop.html" title="Prop"><code>Prop</code></a> type and is either a string for a maps,
or an index for sequences.</p>
<h4 id="conflicts"><a href="#conflicts">Conflicts</a></h4>
<p>There are some things automerge cannot merge sensibly. For example, two
actors concurrently setting the key “name” to different values. In this case
automerge will pick a winning value in a random but deterministic way, but
the conflicting value is still available via the <a href="trait.ReadDoc.html#tymethod.get_all" title="ReadDoc::get_all"><code>ReadDoc::get_all</code></a> method.</p>
<h4 id="change-hashes-and-historical-values"><a href="#change-hashes-and-historical-values">Change hashes and historical values</a></h4>
<p>Like git, points in the history of a document are identified by hash. Unlike
git there can be multiple hashes representing a particular point (because
automerge supports concurrent changes). These hashes can be obtained using
either <a href="struct.Automerge.html#method.get_heads" title="Automerge::get_heads"><code>Automerge::get_heads</code></a> or <a href="struct.AutoCommitWithObs.html#method.get_heads" title="AutoCommit::get_heads"><code>AutoCommit::get_heads</code></a> (note these
methods are not part of <a href="trait.ReadDoc.html" title="ReadDoc"><code>ReadDoc</code></a> because in the case of <a href="type.AutoCommit.html" title="AutoCommit"><code>AutoCommit</code></a> it
requires a mutable reference to the document).</p>
<p>These hashes can be used to read values from the document at a particular
point in history using the various <code>*_at</code> methods on <a href="trait.ReadDoc.html" title="ReadDoc"><code>ReadDoc</code></a> which take a
slice of <a href="struct.ChangeHash.html" title="ChangeHash"><code>ChangeHash</code></a> as an argument.</p>
<h4 id="actor-ids"><a href="#actor-ids">Actor IDs</a></h4>
<p>Any change to an automerge document is made by an actor, represented by an
<a href="struct.ActorId.html" title="ActorId"><code>ActorId</code></a>. An actor ID is any random sequence of bytes but each change by
the same actor ID must be sequential. This often means you will want to
maintain at least one actor ID per device. It is fine to generate a new
actor ID for each change, but be aware that each actor ID takes up space in
a document so if you expect a document to be long lived and/or to have many
changes then you should try to reuse actor IDs where possible.</p>
<h4 id="text-encoding"><a href="#text-encoding">Text Encoding</a></h4>
<p>Both <a href="struct.Automerge.html" title="Automerge"><code>Automerge</code></a> and <a href="type.AutoCommit.html" title="AutoCommit"><code>AutoCommit</code></a> provide a <code>with_encoding</code> method which
allows you to specify the <a href="enum.TextEncoding.html" title="crate::TextEncoding"><code>crate::TextEncoding</code></a> which is used for
interpreting the indexes passed to methods like <a href="trait.ReadDoc.html#tymethod.list_range" title="ReadDoc::list_range"><code>ReadDoc::list_range</code></a> or
<a href="transaction/trait.Transactable.html#tymethod.splice" title="transaction::Transactable::splice"><code>transaction::Transactable::splice</code></a>. The default encoding is UTF-8, but
you can switch to UTF-16.</p>
<h3 id="sync-protocol"><a href="#sync-protocol">Sync Protocol</a></h3>
<p>See the <a href="sync/index.html" title="sync"><code>sync</code></a> module.</p>
<h3 id="serde-serialization"><a href="#serde-serialization">Serde serialization</a></h3>
<p>Sometimes you just want to get the JSON value of an automerge document. For
this you can use <a href="struct.AutoSerde.html" title="AutoSerde"><code>AutoSerde</code></a>, which implements <code>serde::Serialize</code> for an
automerge document.</p>
<h3 id="example"><a href="#example">Example</a></h3>
<p>Let’s create a document representing an address book.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>automerge::{ObjType, AutoCommit, transaction::Transactable, ReadDoc};

<span class="kw">let </span><span class="kw-2">mut </span>doc = AutoCommit::new();

<span class="comment">// `put_object` creates a nested object in the root key/value map and
// returns the ID of the new object, in this case a list.
</span><span class="kw">let </span>contacts = doc.put_object(automerge::ROOT, <span class="string">&quot;contacts&quot;</span>, ObjType::List)<span class="question-mark">?</span>;

<span class="comment">// Now we can insert objects into the list
</span><span class="kw">let </span>alice = doc.insert_object(<span class="kw-2">&amp;</span>contacts, <span class="number">0</span>, ObjType::Map)<span class="question-mark">?</span>;

<span class="comment">// Finally we can set keys in the &quot;alice&quot; map
</span>doc.put(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>)<span class="question-mark">?</span>;
doc.put(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;alice@example.com&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create another contact
</span><span class="kw">let </span>bob = doc.insert_object(<span class="kw-2">&amp;</span>contacts, <span class="number">1</span>, ObjType::Map)<span class="question-mark">?</span>;
doc.put(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>)<span class="question-mark">?</span>;
doc.put(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Now we save the address book, we can put this in a file
</span><span class="kw">let </span>data: Vec&lt;u8&gt; = doc.save();</code></pre></div>
<p>Now modify this document on two separate devices and merge the modifications.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::borrow::Cow;
<span class="kw">use </span>automerge::{ObjType, AutoCommit, transaction::Transactable, ReadDoc};


<span class="comment">// Load the document on the first device and change alices email
</span><span class="kw">let </span><span class="kw-2">mut </span>doc1 = AutoCommit::load(<span class="kw-2">&amp;</span>saved)<span class="question-mark">?</span>;
<span class="kw">let </span>contacts = <span class="kw">match </span>doc1.get(automerge::ROOT, <span class="string">&quot;contacts&quot;</span>)<span class="question-mark">? </span>{
    <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::List), contacts)) =&gt; contacts,
    <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;contacts should be a list&quot;</span>),
};
<span class="kw">let </span>alice = <span class="kw">match </span>doc1.get(<span class="kw-2">&amp;</span>contacts, <span class="number">0</span>)<span class="question-mark">? </span>{
   <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::Map), alice)) =&gt; alice,
   <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;alice should be a map&quot;</span>),
};
doc1.put(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;alicesnewemail@example.com&quot;</span>)<span class="question-mark">?</span>;


<span class="comment">// Load the document on the second device and change bobs name
</span><span class="kw">let </span><span class="kw-2">mut </span>doc2 = AutoCommit::load(<span class="kw-2">&amp;</span>saved)<span class="question-mark">?</span>;
<span class="kw">let </span>contacts = <span class="kw">match </span>doc2.get(automerge::ROOT, <span class="string">&quot;contacts&quot;</span>)<span class="question-mark">? </span>{
   <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::List), contacts)) =&gt; contacts,
   <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;contacts should be a list&quot;</span>),
};
<span class="kw">let </span>bob = <span class="kw">match </span>doc2.get(<span class="kw-2">&amp;</span>contacts, <span class="number">1</span>)<span class="question-mark">? </span>{
  <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::Map), bob)) =&gt; bob,
  <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;bob should be a map&quot;</span>),
};
doc2.put(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Robert&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Finally, we can merge the changes from the two devices
</span>doc1.merge(<span class="kw-2">&amp;mut </span>doc2)<span class="question-mark">?</span>;
<span class="kw">let </span>bobsname: <span class="prelude-ty">Option</span>&lt;automerge::Value&gt; = doc1.get(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;name&quot;</span>)<span class="question-mark">?</span>.map(|(v, <span class="kw">_</span>)| v);
<span class="macro">assert_eq!</span>(bobsname, <span class="prelude-val">Some</span>(automerge::Value::Scalar(Cow::Owned(<span class="string">&quot;Robert&quot;</span>.into()))));

<span class="kw">let </span>alices_email: <span class="prelude-ty">Option</span>&lt;automerge::Value&gt; = doc1.get(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;email&quot;</span>)<span class="question-mark">?</span>.map(|(v, <span class="kw">_</span>)| v);
<span class="macro">assert_eq!</span>(alices_email, <span class="prelude-val">Some</span>(automerge::Value::Scalar(Cow::Owned(<span class="string">&quot;alicesnewemail@example.com&quot;</span>.into()))));</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.OpObserver"><code>pub use op_observer::<a class="trait" href="op_observer/trait.OpObserver.html" title="trait automerge::op_observer::OpObserver">OpObserver</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Patch"><code>pub use op_observer::<a class="enum" href="op_observer/enum.Patch.html" title="enum automerge::op_observer::Patch">Patch</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.VecOpObserver"><code>pub use op_observer::<a class="struct" href="op_observer/struct.VecOpObserver.html" title="struct automerge::op_observer::VecOpObserver">VecOpObserver</a>;</code></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="op_observer/index.html" title="automerge::op_observer mod">op_observer</a></div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="sync/index.html" title="automerge::sync mod">sync</a></div><div class="item-right docblock-short">Sync Protocol</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="transaction/index.html" title="automerge::transaction mod">transaction</a></div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ActorId.html" title="automerge::ActorId struct">ActorId</a></div><div class="item-right docblock-short">An actor id is a sequence of bytes. By default we use a uuid which can be nicely stack
allocated.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AutoCommitWithObs.html" title="automerge::AutoCommitWithObs struct">AutoCommitWithObs</a></div><div class="item-right docblock-short">An automerge document that automatically manages transactions.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AutoSerde.html" title="automerge::AutoSerde struct">AutoSerde</a></div><div class="item-right docblock-short">A wrapper type which implements <a href="https://docs.rs/serde/1.0.152/serde/ser/trait.Serialize.html" title="serde::Serialize"><code>serde::Serialize</code></a> for a <a href="trait.ReadDoc.html" title="ReadDoc"><code>ReadDoc</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Automerge.html" title="automerge::Automerge struct">Automerge</a></div><div class="item-right docblock-short">An automerge document which does not manage transactions for you.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Change.html" title="automerge::Change struct">Change</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ChangeHash.html" title="automerge::ChangeHash struct">ChangeHash</a></div><div class="item-right docblock-short">The sha256 hash of a change.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ExpandedChange.html" title="automerge::ExpandedChange struct">ExpandedChange</a></div><div class="item-right docblock-short">A change represents a group of operations performed by an actor.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InvalidActorId.html" title="automerge::InvalidActorId struct">InvalidActorId</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InvalidChangeHashSlice.html" title="automerge::InvalidChangeHashSlice struct">InvalidChangeHashSlice</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Keys.html" title="automerge::Keys struct">Keys</a></div><div class="item-right docblock-short">An iterator over the keys of an object</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.KeysAt.html" title="automerge::KeysAt struct">KeysAt</a></div><div class="item-right docblock-short">An iterator over the keys of an object at a particular point in history</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ListRange.html" title="automerge::ListRange struct">ListRange</a></div><div class="item-right docblock-short">An iterator over the elements of a list object</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ListRangeAt.html" title="automerge::ListRangeAt struct">ListRangeAt</a></div><div class="item-right docblock-short">An iterator over the elements of a list object at a particular set of heads</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MapRange.html" title="automerge::MapRange struct">MapRange</a></div><div class="item-right docblock-short">An iterator over the keys and values of a map object</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MapRangeAt.html" title="automerge::MapRangeAt struct">MapRangeAt</a></div><div class="item-right docblock-short">An iterator over the keys and values of a map object as at a particuar heads</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Parent.html" title="automerge::Parent struct">Parent</a></div><div class="item-right docblock-short">A component of a path to an object</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Parents.html" title="automerge::Parents struct">Parents</a></div><div class="item-right docblock-short">An iterator over the “parents” of an object</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Values.html" title="automerge::Values struct">Values</a></div><div class="item-right docblock-short">An iterator over the values in an object</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AutomergeError.html" title="automerge::AutomergeError enum">AutomergeError</a></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.LoadChangeError.html" title="automerge::LoadChangeError enum">LoadChangeError</a></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ObjId.html" title="automerge::ObjId enum">ObjId</a></div><div class="item-right docblock-short">An identifier for an object in a document</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ObjIdFromBytesError.html" title="automerge::ObjIdFromBytesError enum">ObjIdFromBytesError</a></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ObjType.html" title="automerge::ObjType enum">ObjType</a></div><div class="item-right docblock-short">The type of an object</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.OnPartialLoad.html" title="automerge::OnPartialLoad enum">OnPartialLoad</a></div><div class="item-right docblock-short">What to do when loading a document partially succeeds</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.OpType.html" title="automerge::OpType enum">OpType</a></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ParseChangeHashError.html" title="automerge::ParseChangeHashError enum">ParseChangeHashError</a></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Prop.html" title="automerge::Prop enum">Prop</a></div><div class="item-right docblock-short">A property of an object</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ScalarValue.html" title="automerge::ScalarValue enum">ScalarValue</a></div><div class="item-right docblock-short">A value which is not a composite value</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.TextEncoding.html" title="automerge::TextEncoding enum">TextEncoding</a></div><div class="item-right docblock-short">How indexes into text sequeces are calculated</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Value.html" title="automerge::Value enum">Value</a></div><div class="item-right docblock-short">The type of values in an automerge document</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.ROOT.html" title="automerge::ROOT constant">ROOT</a></div><div class="item-right docblock-short">The object ID for the root map of a document</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ReadDoc.html" title="automerge::ReadDoc trait">ReadDoc</a></div><div class="item-right docblock-short">Methods for reading values from an automerge document</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.AutoCommit.html" title="automerge::AutoCommit type">AutoCommit</a></div><div class="item-right docblock-short">An autocommit document with no observer</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="automerge" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0 (fc594f156 2023-01-24)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>